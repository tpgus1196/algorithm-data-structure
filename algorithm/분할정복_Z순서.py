#크기가 2^n X 2^n차원 배열이 존재 
#n의 값이 주어질 때, r행 c열을 몇 번째로 방문하는지 알고 싶다
#현재 사각형이 (r,c)를 포함하지 않으면 통째로 건너뛰고, 포함하면 4개로 쪼개며 재귀적으로 찾아가는 방식

import sys
result = 0 #방문 순서 누적 저장용
def sol(n, x, y): #함수 sol(n,x,y)를 정의
    global result #전역변수 값을 함수 내에서 변경
    if x == r and y == c: #기저 사례) 만약 현재 좌표(x,y)가 찾고자 하는(r, c)인 경우(원하는 위치에 도달하는 경우)
        print(int(result)) #지금까지 누적한 result를 정수로 변환하여 출력하고, 함수를 종료
        return
    if not (x <= r < x + n and y <= c < y + n): #만약 (x,y)에서 시작한 n*n 크기 사각형이 (r,c)를-최종적으로 도달해야하는 위치를- 포함하지 않는 경우
        #해당 영역은 한 번에 스킵(필요없는 사각형은 계산만 하고 패스)
        #방문 수를 n*n만큼 통째로 더함
        result += n * n 
        return #재귀적으로 탐색할 필요가 없으므로 해당 사각형의 크기만큼 더해주고 이탈
    
    #현재 사각형을 4개로 쪼개서 재귀적으로 탐색(4>1>3>2 순으로 탐색)
    #4개의 재귀 호출을 사용하여 사분면으로 나눔
    #n이 점점 작아져서, 결국 n=1이면 개별 칸 단위로 체크
    sol(n//2, x, y) #(4사분면 - 왼쪽 위)
    sol(n//2, x, y+n//2) #(1사분면 - 오른쪽 위)
    sol(n//2, x+n//2, y) #(3사분면 - 왼쪽 아래)
    sol(n//2, x+n//2, y+n//2) #(2사분면 - 오른쪽 아래)

n, r, c = map(int, sys.stdin.readline().split(' '))
sol(1<<n, 0, 0) #1<<n = 2ⁿ 크기(길이)가 함수에 들어감.(배열 한 변 길이) 2ⁿ×2ⁿ 크기라는 가상의 크기만 설정 후 (0,0)에서 시작해 전체 배열을 탐색





#n: 현재 탐색하고 있는 사각형 한 변의 길이
#(x,y): 현재 사각형의 왼쪽 위 좌표
#r: 목표 위치의 행 인덱스 
#c: 목표 위치의 열 인덱스
#result += n*n 하는 이유: (r,c)가 포함되지 않은 사각형이면, 그 사각형 안의 모든 칸을 다 지나쳤다고 생각하고 result에 그 칸 수 만큼 더해버리는 것
#1<<n: 1을 왼쪽으로 n칸 이동 = 2ⁿ. <<는 비트 연산자. 2의 거듭제곱을 빨리 계산하는 트릭