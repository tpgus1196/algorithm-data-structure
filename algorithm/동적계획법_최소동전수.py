#그리디 알고리즘으로 해결 가능
#1000원짜리 커피를 500원짜리 동전과 100원짜리 동전만 사용하여 계산하려고 할 때
#동전을 가장 적게 사용하여 계산 시 필요한 동전의 최소 개수


#그리디 알고리즘으로 해결 불가능
#23원짜리 커피를 5원짜리 동전과 3원짜리 동전만 사용하여 계산하려고 할 때
#동전을 가장 적게 사용하여 계산한다면 필요한 동전의 최소 개수는?
#그리디 알고리즘 적용가능 조건 중, '최적 부분 구조 조건'을 만족하지 않기 때문
#지역적으로도 전역적으로도 최적이 아님

#Bottom-Up 동적 계획법으로 해결: 
#n원을 가장 적은 동전으로 만드는 방법
#n-3원, n-5원 문제를 이용해서 푸는 것

n = int(input())

#dp[i] = 1원을 만들기 위한 최소 동전 개수
#처음에는 불가능한 값으로 초기화(큰 수)
dp = [float('inf')] * (n+1) 

#3원, 5원은 각각 동전 1개로 만들 수 있음
#if 안해주면 배열 길이가 안맞아서 1일때 -1이 안나옴
if n >= 3:
    dp[3] = 1
if n >= 5:
    dp[5] = 1

#2원부터 n+1원까지 각 금액을 만들 수 있는 최소 동전 개수 계산
#i = 동전으로 만들고 싶은 금액 = dp의 인덱스
for i in range(6, n+1): #1,2,4원은 3원과 5원으로 만들 수 없으므로 의미가 없다
    #아래 둘 중 최소 동전개수를 선택한다
    
    #i원이 되기 위해 5원을 추가한 경우
    if dp[i-5] != float('inf'):
        dp[i] = min(dp[i], dp[i-5] + 1)
    
    #i원이 되기 위해 3원을 추가한 경우
    if dp[i-3] != float('inf'):
        dp[i] = min(dp[i], dp[i-3] + 1)

print(-1 if dp[n] == float('inf') else dp[n])